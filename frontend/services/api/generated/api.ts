/* tslint:disable */
/* eslint-disable */
/**
 * runappapi
 * The API that powers the RunApp platform
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Album
 */
export interface Album {
    /**
     * Le URI de l\'album
     * @type {string}
     * @memberof Album
     */
    uri: string;
    /**
     * Le nom de l\'album
     * @type {string}
     * @memberof Album
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Album
     */
    photoCount: number;
    /**
     * 
     * @type {string}
     * @memberof Album
     */
    updatedDate: string;
    /**
     * 
     * @type {string}
     * @memberof Album
     */
    createdDate: string;
    /**
     * 
     * @type {string}
     * @memberof Album
     */
    eventId: string;
    /**
     * 
     * @type {string}
     * @memberof Album
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof Album
     */
    id: string;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    banner: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    logo: string;
    /**
     * L\'URI de l\'organisation
     * @type {string}
     * @memberof Organization
     */
    uri: string;
    /**
     * Le nom de l\'organisation
     * @type {string}
     * @memberof Organization
     */
    name: string;
    /**
     * 
     * @type {Array<OrganizationMembers>}
     * @memberof Organization
     */
    members: Array<OrganizationMembers>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Organization
     */
    membersIds: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Organization
     */
    photoCount: number;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    updatedDate: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    createdDate: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    id: string;
}
/**
 * 
 * @export
 * @interface OrganizationMembers
 */
export interface OrganizationMembers {
    /**
     * 
     * @type {Array<string>}
     * @memberof OrganizationMembers
     */
    permissions: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OrganizationMembers
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationMembers
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface Photo
 */
export interface Photo {
    /**
     * 
     * @type {string}
     * @memberof Photo
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof Photo
     */
    portrait: boolean;
    /**
     * 
     * @type {number}
     * @memberof Photo
     */
    height: number;
    /**
     * 
     * @type {number}
     * @memberof Photo
     */
    width: number;
    /**
     * 
     * @type {number}
     * @memberof Photo
     */
    price: PhotoPriceEnum;
    /**
     * L\'URL de téléchargement de la photo telle qu\'affichée sur le site
     * @type {string}
     * @memberof Photo
     */
    previewImageUrl: string;
    /**
     * L\'URL de téléchargement de la photo originale
     * @type {string}
     * @memberof Photo
     */
    sourceImageUrl: string;
    /**
     * Date à laquelle la photo a été analysée
     * @type {string}
     * @memberof Photo
     */
    analysisDate?: string;
    /**
     * Valeur booléenne indiquant si les numéros de bibs ont été extraits de la photo
     * @type {boolean}
     * @memberof Photo
     */
    haveBibsBeenChecked: boolean;
    /**
     * Une liste des BIBs associés à la photo
     * @type {Array<string>}
     * @memberof Photo
     */
    bibNumbers: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Photo
     */
    albumId: string;
    /**
     * 
     * @type {string}
     * @memberof Photo
     */
    eventId: string;
    /**
     * 
     * @type {string}
     * @memberof Photo
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof Photo
     */
    id: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PhotoPriceEnum {
    NUMBER_0 = 0
}

/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickAlbumNameOrUri
 */
export interface PickAlbumNameOrUri {
    /**
     * Le nom de l\'album
     * @type {string}
     * @memberof PickAlbumNameOrUri
     */
    name: string;
    /**
     * Le URI de l\'album
     * @type {string}
     * @memberof PickAlbumNameOrUri
     */
    uri: string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickOrganizationNameOrUriOrLogoOrBanner
 */
export interface PickOrganizationNameOrUriOrLogoOrBanner {
    /**
     * Le nom de l\'organisation
     * @type {string}
     * @memberof PickOrganizationNameOrUriOrLogoOrBanner
     */
    name: string;
    /**
     * L\'URI de l\'organisation
     * @type {string}
     * @memberof PickOrganizationNameOrUriOrLogoOrBanner
     */
    uri: string;
    /**
     * 
     * @type {string}
     * @memberof PickOrganizationNameOrUriOrLogoOrBanner
     */
    logo: string;
    /**
     * 
     * @type {string}
     * @memberof PickOrganizationNameOrUriOrLogoOrBanner
     */
    banner: string;
}
/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickPhotoExcludeKeyofPhotoSourceImageUrl
 */
export interface PickPhotoExcludeKeyofPhotoSourceImageUrl {
    /**
     * 
     * @type {string}
     * @memberof PickPhotoExcludeKeyofPhotoSourceImageUrl
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PickPhotoExcludeKeyofPhotoSourceImageUrl
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof PickPhotoExcludeKeyofPhotoSourceImageUrl
     */
    organizationId: string;
    /**
     * 
     * @type {string}
     * @memberof PickPhotoExcludeKeyofPhotoSourceImageUrl
     */
    eventId: string;
    /**
     * 
     * @type {string}
     * @memberof PickPhotoExcludeKeyofPhotoSourceImageUrl
     */
    albumId: string;
    /**
     * Une liste des BIBs associés à la photo
     * @type {Array<string>}
     * @memberof PickPhotoExcludeKeyofPhotoSourceImageUrl
     */
    bibNumbers: Array<string>;
    /**
     * Valeur booléenne indiquant si les numéros de bibs ont été extraits de la photo
     * @type {boolean}
     * @memberof PickPhotoExcludeKeyofPhotoSourceImageUrl
     */
    haveBibsBeenChecked: boolean;
    /**
     * Date à laquelle la photo a été analysée
     * @type {string}
     * @memberof PickPhotoExcludeKeyofPhotoSourceImageUrl
     */
    analysisDate?: string;
    /**
     * L\'URL de téléchargement de la photo telle qu\'affichée sur le site
     * @type {string}
     * @memberof PickPhotoExcludeKeyofPhotoSourceImageUrl
     */
    previewImageUrl: string;
    /**
     * 
     * @type {number}
     * @memberof PickPhotoExcludeKeyofPhotoSourceImageUrl
     */
    price: PickPhotoExcludeKeyofPhotoSourceImageUrlPriceEnum;
    /**
     * 
     * @type {number}
     * @memberof PickPhotoExcludeKeyofPhotoSourceImageUrl
     */
    width: number;
    /**
     * 
     * @type {number}
     * @memberof PickPhotoExcludeKeyofPhotoSourceImageUrl
     */
    height: number;
    /**
     * 
     * @type {boolean}
     * @memberof PickPhotoExcludeKeyofPhotoSourceImageUrl
     */
    portrait: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum PickPhotoExcludeKeyofPhotoSourceImageUrlPriceEnum {
    NUMBER_0 = 0
}

/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickRacingEventEventDateOrNameOrImageOrUri
 */
export interface PickRacingEventEventDateOrNameOrImageOrUri {
    /**
     * Le nom de l\'événement
     * @type {string}
     * @memberof PickRacingEventEventDateOrNameOrImageOrUri
     */
    name: string;
    /**
     * L\'URI de l\'événement
     * @type {string}
     * @memberof PickRacingEventEventDateOrNameOrImageOrUri
     */
    uri: string;
    /**
     * La date de l\'événement
     * @type {string}
     * @memberof PickRacingEventEventDateOrNameOrImageOrUri
     */
    eventDate: string;
    /**
     * 
     * @type {string}
     * @memberof PickRacingEventEventDateOrNameOrImageOrUri
     */
    image: string;
}
/**
 * 
 * @export
 * @interface RacingEvent
 */
export interface RacingEvent {
    /**
     * 
     * @type {string}
     * @memberof RacingEvent
     */
    image: string;
    /**
     * La date de l\'événement
     * @type {string}
     * @memberof RacingEvent
     */
    eventDate: string;
    /**
     * L\'URI de l\'événement
     * @type {string}
     * @memberof RacingEvent
     */
    uri: string;
    /**
     * Le nom de l\'événement
     * @type {string}
     * @memberof RacingEvent
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof RacingEvent
     */
    photoCount: number;
    /**
     * 
     * @type {string}
     * @memberof RacingEvent
     */
    updatedDate: string;
    /**
     * 
     * @type {string}
     * @memberof RacingEvent
     */
    createdDate: string;
    /**
     * 
     * @type {string}
     * @memberof RacingEvent
     */
    organisationId: string;
    /**
     * 
     * @type {string}
     * @memberof RacingEvent
     */
    id: string;
}
/**
 * 
 * @export
 * @interface UpdateEventDto
 */
export interface UpdateEventDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateEventDto
     */
    image: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventDto
     */
    eventDate: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventDto
     */
    uri: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventDto
     */
    id: string;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationDto
 */
export interface UpdateOrganizationDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    banner: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    logo: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    uri: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationDto
     */
    id: string;
}

/**
 * AlbumsApi - axios parameter creator
 * @export
 */
export const AlbumsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new album for the given event in the given organization
         * @param {string} orgUri The organization URI
         * @param {string} eventUri The event URI
         * @param {PickAlbumNameOrUri} body The album to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum: async (orgUri: string, eventUri: string, body: PickAlbumNameOrUri, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgUri' is not null or undefined
            if (orgUri === null || orgUri === undefined) {
                throw new RequiredError('orgUri','Required parameter orgUri was null or undefined when calling createAlbum.');
            }
            // verify required parameter 'eventUri' is not null or undefined
            if (eventUri === null || eventUri === undefined) {
                throw new RequiredError('eventUri','Required parameter eventUri was null or undefined when calling createAlbum.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createAlbum.');
            }
            const localVarPath = `/albums`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firebase required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (orgUri !== undefined) {
                localVarQueryParameter['orgUri'] = orgUri;
            }

            if (eventUri !== undefined) {
                localVarQueryParameter['eventUri'] = eventUri;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the album for the given organization, event, and album URI
         * @param {string} orgUri The organization URI
         * @param {string} eventUri The event URI
         * @param {string} albumUri The album URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAlbumByUri: async (orgUri: string, eventUri: string, albumUri: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgUri' is not null or undefined
            if (orgUri === null || orgUri === undefined) {
                throw new RequiredError('orgUri','Required parameter orgUri was null or undefined when calling findAlbumByUri.');
            }
            // verify required parameter 'eventUri' is not null or undefined
            if (eventUri === null || eventUri === undefined) {
                throw new RequiredError('eventUri','Required parameter eventUri was null or undefined when calling findAlbumByUri.');
            }
            // verify required parameter 'albumUri' is not null or undefined
            if (albumUri === null || albumUri === undefined) {
                throw new RequiredError('albumUri','Required parameter albumUri was null or undefined when calling findAlbumByUri.');
            }
            const localVarPath = `/albums/{albumUri}`
                .replace(`{${"albumUri"}}`, encodeURIComponent(String(albumUri)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orgUri !== undefined) {
                localVarQueryParameter['orgUri'] = orgUri;
            }

            if (eventUri !== undefined) {
                localVarQueryParameter['eventUri'] = eventUri;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all albums for the given event in the given organization
         * @param {string} orgUri The organization URI
         * @param {string} eventUri The event URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEventAlbums: async (orgUri: string, eventUri: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgUri' is not null or undefined
            if (orgUri === null || orgUri === undefined) {
                throw new RequiredError('orgUri','Required parameter orgUri was null or undefined when calling findEventAlbums.');
            }
            // verify required parameter 'eventUri' is not null or undefined
            if (eventUri === null || eventUri === undefined) {
                throw new RequiredError('eventUri','Required parameter eventUri was null or undefined when calling findEventAlbums.');
            }
            const localVarPath = `/albums`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orgUri !== undefined) {
                localVarQueryParameter['orgUri'] = orgUri;
            }

            if (eventUri !== undefined) {
                localVarQueryParameter['eventUri'] = eventUri;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies an album for the given event in the given organization
         * @param {string} orgUri The organization URI
         * @param {string} eventUri The event URI
         * @param {string} albumUri The event URI
         * @param {PickAlbumNameOrUri} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyAlbum: async (orgUri: string, eventUri: string, albumUri: string, body: PickAlbumNameOrUri, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgUri' is not null or undefined
            if (orgUri === null || orgUri === undefined) {
                throw new RequiredError('orgUri','Required parameter orgUri was null or undefined when calling modifyAlbum.');
            }
            // verify required parameter 'eventUri' is not null or undefined
            if (eventUri === null || eventUri === undefined) {
                throw new RequiredError('eventUri','Required parameter eventUri was null or undefined when calling modifyAlbum.');
            }
            // verify required parameter 'albumUri' is not null or undefined
            if (albumUri === null || albumUri === undefined) {
                throw new RequiredError('albumUri','Required parameter albumUri was null or undefined when calling modifyAlbum.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modifyAlbum.');
            }
            const localVarPath = `/albums`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firebase required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (orgUri !== undefined) {
                localVarQueryParameter['orgUri'] = orgUri;
            }

            if (eventUri !== undefined) {
                localVarQueryParameter['eventUri'] = eventUri;
            }

            if (albumUri !== undefined) {
                localVarQueryParameter['albumUri'] = albumUri;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlbumsApi - functional programming interface
 * @export
 */
export const AlbumsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new album for the given event in the given organization
         * @param {string} orgUri The organization URI
         * @param {string} eventUri The event URI
         * @param {PickAlbumNameOrUri} body The album to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlbum(orgUri: string, eventUri: string, body: PickAlbumNameOrUri, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Album>> {
            const localVarAxiosArgs = await AlbumsApiAxiosParamCreator(configuration).createAlbum(orgUri, eventUri, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the album for the given organization, event, and album URI
         * @param {string} orgUri The organization URI
         * @param {string} eventUri The event URI
         * @param {string} albumUri The album URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAlbumByUri(orgUri: string, eventUri: string, albumUri: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Album>> {
            const localVarAxiosArgs = await AlbumsApiAxiosParamCreator(configuration).findAlbumByUri(orgUri, eventUri, albumUri, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves all albums for the given event in the given organization
         * @param {string} orgUri The organization URI
         * @param {string} eventUri The event URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findEventAlbums(orgUri: string, eventUri: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Album>>> {
            const localVarAxiosArgs = await AlbumsApiAxiosParamCreator(configuration).findEventAlbums(orgUri, eventUri, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modifies an album for the given event in the given organization
         * @param {string} orgUri The organization URI
         * @param {string} eventUri The event URI
         * @param {string} albumUri The event URI
         * @param {PickAlbumNameOrUri} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyAlbum(orgUri: string, eventUri: string, albumUri: string, body: PickAlbumNameOrUri, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Album>> {
            const localVarAxiosArgs = await AlbumsApiAxiosParamCreator(configuration).modifyAlbum(orgUri, eventUri, albumUri, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AlbumsApi - factory interface
 * @export
 */
export const AlbumsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a new album for the given event in the given organization
         * @param {string} orgUri The organization URI
         * @param {string} eventUri The event URI
         * @param {PickAlbumNameOrUri} body The album to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlbum(orgUri: string, eventUri: string, body: PickAlbumNameOrUri, options?: any): AxiosPromise<Album> {
            return AlbumsApiFp(configuration).createAlbum(orgUri, eventUri, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the album for the given organization, event, and album URI
         * @param {string} orgUri The organization URI
         * @param {string} eventUri The event URI
         * @param {string} albumUri The album URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAlbumByUri(orgUri: string, eventUri: string, albumUri: string, options?: any): AxiosPromise<Album> {
            return AlbumsApiFp(configuration).findAlbumByUri(orgUri, eventUri, albumUri, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all albums for the given event in the given organization
         * @param {string} orgUri The organization URI
         * @param {string} eventUri The event URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEventAlbums(orgUri: string, eventUri: string, options?: any): AxiosPromise<Array<Album>> {
            return AlbumsApiFp(configuration).findEventAlbums(orgUri, eventUri, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies an album for the given event in the given organization
         * @param {string} orgUri The organization URI
         * @param {string} eventUri The event URI
         * @param {string} albumUri The event URI
         * @param {PickAlbumNameOrUri} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyAlbum(orgUri: string, eventUri: string, albumUri: string, body: PickAlbumNameOrUri, options?: any): AxiosPromise<Album> {
            return AlbumsApiFp(configuration).modifyAlbum(orgUri, eventUri, albumUri, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAlbum operation in AlbumsApi.
 * @export
 * @interface AlbumsApiCreateAlbumRequest
 */
export interface AlbumsApiCreateAlbumRequest {
    /**
     * The organization URI
     * @type {string}
     * @memberof AlbumsApiCreateAlbum
     */
    readonly orgUri: string

    /**
     * The event URI
     * @type {string}
     * @memberof AlbumsApiCreateAlbum
     */
    readonly eventUri: string

    /**
     * The album to create
     * @type {PickAlbumNameOrUri}
     * @memberof AlbumsApiCreateAlbum
     */
    readonly body: PickAlbumNameOrUri
}

/**
 * Request parameters for findAlbumByUri operation in AlbumsApi.
 * @export
 * @interface AlbumsApiFindAlbumByUriRequest
 */
export interface AlbumsApiFindAlbumByUriRequest {
    /**
     * The organization URI
     * @type {string}
     * @memberof AlbumsApiFindAlbumByUri
     */
    readonly orgUri: string

    /**
     * The event URI
     * @type {string}
     * @memberof AlbumsApiFindAlbumByUri
     */
    readonly eventUri: string

    /**
     * The album URI
     * @type {string}
     * @memberof AlbumsApiFindAlbumByUri
     */
    readonly albumUri: string
}

/**
 * Request parameters for findEventAlbums operation in AlbumsApi.
 * @export
 * @interface AlbumsApiFindEventAlbumsRequest
 */
export interface AlbumsApiFindEventAlbumsRequest {
    /**
     * The organization URI
     * @type {string}
     * @memberof AlbumsApiFindEventAlbums
     */
    readonly orgUri: string

    /**
     * The event URI
     * @type {string}
     * @memberof AlbumsApiFindEventAlbums
     */
    readonly eventUri: string
}

/**
 * Request parameters for modifyAlbum operation in AlbumsApi.
 * @export
 * @interface AlbumsApiModifyAlbumRequest
 */
export interface AlbumsApiModifyAlbumRequest {
    /**
     * The organization URI
     * @type {string}
     * @memberof AlbumsApiModifyAlbum
     */
    readonly orgUri: string

    /**
     * The event URI
     * @type {string}
     * @memberof AlbumsApiModifyAlbum
     */
    readonly eventUri: string

    /**
     * The event URI
     * @type {string}
     * @memberof AlbumsApiModifyAlbum
     */
    readonly albumUri: string

    /**
     * 
     * @type {PickAlbumNameOrUri}
     * @memberof AlbumsApiModifyAlbum
     */
    readonly body: PickAlbumNameOrUri
}

/**
 * AlbumsApi - object-oriented interface
 * @export
 * @class AlbumsApi
 * @extends {BaseAPI}
 */
export class AlbumsApi extends BaseAPI {
    /**
     * Creates a new album for the given event in the given organization
     * @param {AlbumsApiCreateAlbumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public createAlbum(requestParameters: AlbumsApiCreateAlbumRequest, options?: any) {
        return AlbumsApiFp(this.configuration).createAlbum(requestParameters.orgUri, requestParameters.eventUri, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the album for the given organization, event, and album URI
     * @param {AlbumsApiFindAlbumByUriRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public findAlbumByUri(requestParameters: AlbumsApiFindAlbumByUriRequest, options?: any) {
        return AlbumsApiFp(this.configuration).findAlbumByUri(requestParameters.orgUri, requestParameters.eventUri, requestParameters.albumUri, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all albums for the given event in the given organization
     * @param {AlbumsApiFindEventAlbumsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public findEventAlbums(requestParameters: AlbumsApiFindEventAlbumsRequest, options?: any) {
        return AlbumsApiFp(this.configuration).findEventAlbums(requestParameters.orgUri, requestParameters.eventUri, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modifies an album for the given event in the given organization
     * @param {AlbumsApiModifyAlbumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public modifyAlbum(requestParameters: AlbumsApiModifyAlbumRequest, options?: any) {
        return AlbumsApiFp(this.configuration).modifyAlbum(requestParameters.orgUri, requestParameters.eventUri, requestParameters.albumUri, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new event for the given organization
         * @param {string} orgUri The organization URI
         * @param {PickRacingEventEventDateOrNameOrImageOrUri} body The event to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (orgUri: string, body: PickRacingEventEventDateOrNameOrImageOrUri, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgUri' is not null or undefined
            if (orgUri === null || orgUri === undefined) {
                throw new RequiredError('orgUri','Required parameter orgUri was null or undefined when calling createEvent.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createEvent.');
            }
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firebase required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (orgUri !== undefined) {
                localVarQueryParameter['orgUri'] = orgUri;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the event for the given organization and event uri
         * @param {string} orgUri The organization uri
         * @param {string} eventUri The event uri
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEventByUri: async (orgUri: string, eventUri: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgUri' is not null or undefined
            if (orgUri === null || orgUri === undefined) {
                throw new RequiredError('orgUri','Required parameter orgUri was null or undefined when calling findEventByUri.');
            }
            // verify required parameter 'eventUri' is not null or undefined
            if (eventUri === null || eventUri === undefined) {
                throw new RequiredError('eventUri','Required parameter eventUri was null or undefined when calling findEventByUri.');
            }
            const localVarPath = `/events/{eventUri}`
                .replace(`{${"eventUri"}}`, encodeURIComponent(String(eventUri)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orgUri !== undefined) {
                localVarQueryParameter['orgUri'] = orgUri;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all events for the given organization
         * @param {string} orgUri The organization uri
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganizationsEvents: async (orgUri: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgUri' is not null or undefined
            if (orgUri === null || orgUri === undefined) {
                throw new RequiredError('orgUri','Required parameter orgUri was null or undefined when calling findOrganizationsEvents.');
            }
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orgUri !== undefined) {
                localVarQueryParameter['orgUri'] = orgUri;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgUri 
         * @param {UpdateEventDto} updateEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent: async (orgUri: string, updateEventDto: UpdateEventDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgUri' is not null or undefined
            if (orgUri === null || orgUri === undefined) {
                throw new RequiredError('orgUri','Required parameter orgUri was null or undefined when calling updateEvent.');
            }
            // verify required parameter 'updateEventDto' is not null or undefined
            if (updateEventDto === null || updateEventDto === undefined) {
                throw new RequiredError('updateEventDto','Required parameter updateEventDto was null or undefined when calling updateEvent.');
            }
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firebase required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (orgUri !== undefined) {
                localVarQueryParameter['orgUri'] = orgUri;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof updateEventDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(updateEventDto !== undefined ? updateEventDto : {})
                : (updateEventDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new event for the given organization
         * @param {string} orgUri The organization URI
         * @param {PickRacingEventEventDateOrNameOrImageOrUri} body The event to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(orgUri: string, body: PickRacingEventEventDateOrNameOrImageOrUri, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RacingEvent>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).createEvent(orgUri, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the event for the given organization and event uri
         * @param {string} orgUri The organization uri
         * @param {string} eventUri The event uri
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findEventByUri(orgUri: string, eventUri: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RacingEvent>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).findEventByUri(orgUri, eventUri, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves all events for the given organization
         * @param {string} orgUri The organization uri
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOrganizationsEvents(orgUri: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RacingEvent>>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).findOrganizationsEvents(orgUri, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} orgUri 
         * @param {UpdateEventDto} updateEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEvent(orgUri: string, updateEventDto: UpdateEventDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RacingEvent>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).updateEvent(orgUri, updateEventDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a new event for the given organization
         * @param {string} orgUri The organization URI
         * @param {PickRacingEventEventDateOrNameOrImageOrUri} body The event to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(orgUri: string, body: PickRacingEventEventDateOrNameOrImageOrUri, options?: any): AxiosPromise<RacingEvent> {
            return EventsApiFp(configuration).createEvent(orgUri, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the event for the given organization and event uri
         * @param {string} orgUri The organization uri
         * @param {string} eventUri The event uri
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEventByUri(orgUri: string, eventUri: string, options?: any): AxiosPromise<RacingEvent> {
            return EventsApiFp(configuration).findEventByUri(orgUri, eventUri, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all events for the given organization
         * @param {string} orgUri The organization uri
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganizationsEvents(orgUri: string, options?: any): AxiosPromise<Array<RacingEvent>> {
            return EventsApiFp(configuration).findOrganizationsEvents(orgUri, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgUri 
         * @param {UpdateEventDto} updateEventDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEvent(orgUri: string, updateEventDto: UpdateEventDto, options?: any): AxiosPromise<RacingEvent> {
            return EventsApiFp(configuration).updateEvent(orgUri, updateEventDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createEvent operation in EventsApi.
 * @export
 * @interface EventsApiCreateEventRequest
 */
export interface EventsApiCreateEventRequest {
    /**
     * The organization URI
     * @type {string}
     * @memberof EventsApiCreateEvent
     */
    readonly orgUri: string

    /**
     * The event to create
     * @type {PickRacingEventEventDateOrNameOrImageOrUri}
     * @memberof EventsApiCreateEvent
     */
    readonly body: PickRacingEventEventDateOrNameOrImageOrUri
}

/**
 * Request parameters for findEventByUri operation in EventsApi.
 * @export
 * @interface EventsApiFindEventByUriRequest
 */
export interface EventsApiFindEventByUriRequest {
    /**
     * The organization uri
     * @type {string}
     * @memberof EventsApiFindEventByUri
     */
    readonly orgUri: string

    /**
     * The event uri
     * @type {string}
     * @memberof EventsApiFindEventByUri
     */
    readonly eventUri: string
}

/**
 * Request parameters for findOrganizationsEvents operation in EventsApi.
 * @export
 * @interface EventsApiFindOrganizationsEventsRequest
 */
export interface EventsApiFindOrganizationsEventsRequest {
    /**
     * The organization uri
     * @type {string}
     * @memberof EventsApiFindOrganizationsEvents
     */
    readonly orgUri: string
}

/**
 * Request parameters for updateEvent operation in EventsApi.
 * @export
 * @interface EventsApiUpdateEventRequest
 */
export interface EventsApiUpdateEventRequest {
    /**
     * 
     * @type {string}
     * @memberof EventsApiUpdateEvent
     */
    readonly orgUri: string

    /**
     * 
     * @type {UpdateEventDto}
     * @memberof EventsApiUpdateEvent
     */
    readonly updateEventDto: UpdateEventDto
}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Creates a new event for the given organization
     * @param {EventsApiCreateEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEvent(requestParameters: EventsApiCreateEventRequest, options?: any) {
        return EventsApiFp(this.configuration).createEvent(requestParameters.orgUri, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the event for the given organization and event uri
     * @param {EventsApiFindEventByUriRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public findEventByUri(requestParameters: EventsApiFindEventByUriRequest, options?: any) {
        return EventsApiFp(this.configuration).findEventByUri(requestParameters.orgUri, requestParameters.eventUri, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all events for the given organization
     * @param {EventsApiFindOrganizationsEventsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public findOrganizationsEvents(requestParameters: EventsApiFindOrganizationsEventsRequest, options?: any) {
        return EventsApiFp(this.configuration).findOrganizationsEvents(requestParameters.orgUri, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EventsApiUpdateEventRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateEvent(requestParameters: EventsApiUpdateEventRequest, options?: any) {
        return EventsApiFp(this.configuration).updateEvent(requestParameters.orgUri, requestParameters.updateEventDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new organization with the passed information
         * @param {PickOrganizationNameOrUriOrLogoOrBanner} body The new organization data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: async (body: PickOrganizationNameOrUriOrLogoOrBanner, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createOrganization.');
            }
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firebase required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the organization with the specified uri
         * @param {string} orgUri The uri of the desired organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganizationByUri: async (orgUri: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgUri' is not null or undefined
            if (orgUri === null || orgUri === undefined) {
                throw new RequiredError('orgUri','Required parameter orgUri was null or undefined when calling findOrganizationByUri.');
            }
            const localVarPath = `/organizations/{orgUri}`
                .replace(`{${"orgUri"}}`, encodeURIComponent(String(orgUri)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the organizations of a specific user
         * @param {string} userId The user id for which you want to retrieve the organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserOrganizations: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling findUserOrganizations.');
            }
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firebase required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgUri 
         * @param {UpdateOrganizationDto} updateOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: async (orgUri: string, updateOrganizationDto: UpdateOrganizationDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgUri' is not null or undefined
            if (orgUri === null || orgUri === undefined) {
                throw new RequiredError('orgUri','Required parameter orgUri was null or undefined when calling updateOrganization.');
            }
            // verify required parameter 'updateOrganizationDto' is not null or undefined
            if (updateOrganizationDto === null || updateOrganizationDto === undefined) {
                throw new RequiredError('updateOrganizationDto','Required parameter updateOrganizationDto was null or undefined when calling updateOrganization.');
            }
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firebase required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (orgUri !== undefined) {
                localVarQueryParameter['orgUri'] = orgUri;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof updateOrganizationDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(updateOrganizationDto !== undefined ? updateOrganizationDto : {})
                : (updateOrganizationDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new organization with the passed information
         * @param {PickOrganizationNameOrUriOrLogoOrBanner} body The new organization data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganization(body: PickOrganizationNameOrUriOrLogoOrBanner, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await OrganizationsApiAxiosParamCreator(configuration).createOrganization(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the organization with the specified uri
         * @param {string} orgUri The uri of the desired organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOrganizationByUri(orgUri: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await OrganizationsApiAxiosParamCreator(configuration).findOrganizationByUri(orgUri, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the organizations of a specific user
         * @param {string} userId The user id for which you want to retrieve the organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserOrganizations(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await OrganizationsApiAxiosParamCreator(configuration).findUserOrganizations(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} orgUri 
         * @param {UpdateOrganizationDto} updateOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganization(orgUri: string, updateOrganizationDto: UpdateOrganizationDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await OrganizationsApiAxiosParamCreator(configuration).updateOrganization(orgUri, updateOrganizationDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a new organization with the passed information
         * @param {PickOrganizationNameOrUriOrLogoOrBanner} body The new organization data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(body: PickOrganizationNameOrUriOrLogoOrBanner, options?: any): AxiosPromise<Organization> {
            return OrganizationsApiFp(configuration).createOrganization(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the organization with the specified uri
         * @param {string} orgUri The uri of the desired organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganizationByUri(orgUri: string, options?: any): AxiosPromise<Organization> {
            return OrganizationsApiFp(configuration).findOrganizationByUri(orgUri, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the organizations of a specific user
         * @param {string} userId The user id for which you want to retrieve the organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserOrganizations(userId: string, options?: any): AxiosPromise<Array<Organization>> {
            return OrganizationsApiFp(configuration).findUserOrganizations(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgUri 
         * @param {UpdateOrganizationDto} updateOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(orgUri: string, updateOrganizationDto: UpdateOrganizationDto, options?: any): AxiosPromise<Organization> {
            return OrganizationsApiFp(configuration).updateOrganization(orgUri, updateOrganizationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createOrganization operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiCreateOrganizationRequest
 */
export interface OrganizationsApiCreateOrganizationRequest {
    /**
     * The new organization data
     * @type {PickOrganizationNameOrUriOrLogoOrBanner}
     * @memberof OrganizationsApiCreateOrganization
     */
    readonly body: PickOrganizationNameOrUriOrLogoOrBanner
}

/**
 * Request parameters for findOrganizationByUri operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiFindOrganizationByUriRequest
 */
export interface OrganizationsApiFindOrganizationByUriRequest {
    /**
     * The uri of the desired organization
     * @type {string}
     * @memberof OrganizationsApiFindOrganizationByUri
     */
    readonly orgUri: string
}

/**
 * Request parameters for findUserOrganizations operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiFindUserOrganizationsRequest
 */
export interface OrganizationsApiFindUserOrganizationsRequest {
    /**
     * The user id for which you want to retrieve the organizations
     * @type {string}
     * @memberof OrganizationsApiFindUserOrganizations
     */
    readonly userId: string
}

/**
 * Request parameters for updateOrganization operation in OrganizationsApi.
 * @export
 * @interface OrganizationsApiUpdateOrganizationRequest
 */
export interface OrganizationsApiUpdateOrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationsApiUpdateOrganization
     */
    readonly orgUri: string

    /**
     * 
     * @type {UpdateOrganizationDto}
     * @memberof OrganizationsApiUpdateOrganization
     */
    readonly updateOrganizationDto: UpdateOrganizationDto
}

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * Creates a new organization with the passed information
     * @param {OrganizationsApiCreateOrganizationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public createOrganization(requestParameters: OrganizationsApiCreateOrganizationRequest, options?: any) {
        return OrganizationsApiFp(this.configuration).createOrganization(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the organization with the specified uri
     * @param {OrganizationsApiFindOrganizationByUriRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public findOrganizationByUri(requestParameters: OrganizationsApiFindOrganizationByUriRequest, options?: any) {
        return OrganizationsApiFp(this.configuration).findOrganizationByUri(requestParameters.orgUri, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the organizations of a specific user
     * @param {OrganizationsApiFindUserOrganizationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public findUserOrganizations(requestParameters: OrganizationsApiFindUserOrganizationsRequest, options?: any) {
        return OrganizationsApiFp(this.configuration).findUserOrganizations(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OrganizationsApiUpdateOrganizationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public updateOrganization(requestParameters: OrganizationsApiUpdateOrganizationRequest, options?: any) {
        return OrganizationsApiFp(this.configuration).updateOrganization(requestParameters.orgUri, requestParameters.updateOrganizationDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PhotosApi - axios parameter creator
 * @export
 */
export const PhotosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the photo for the given id
         * @param {string} photoId The id of the photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhoto: async (photoId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'photoId' is not null or undefined
            if (photoId === null || photoId === undefined) {
                throw new RequiredError('photoId','Required parameter photoId was null or undefined when calling deletePhoto.');
            }
            const localVarPath = `/photos/{photoId}`
                .replace(`{${"photoId"}}`, encodeURIComponent(String(photoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication firebase required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the photos for a given event, optionally filtered by albums and bib number
         * @param {string} eventId The event id
         * @param {string} [albumsIdsString] 
         * @param {string} [lastPagePhotoId] 
         * @param {string} [bibNumber] The bib number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEventPhotos: async (eventId: string, albumsIdsString?: string, lastPagePhotoId?: string, bibNumber?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling findEventPhotos.');
            }
            const localVarPath = `/photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (albumsIdsString !== undefined) {
                localVarQueryParameter['albumsIdsString'] = albumsIdsString;
            }

            if (lastPagePhotoId !== undefined) {
                localVarQueryParameter['lastPagePhotoId'] = lastPagePhotoId;
            }

            if (bibNumber !== undefined) {
                localVarQueryParameter['bibNumber'] = bibNumber;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the photo for the given id
         * @param {string} photoId The id of the photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPhoto: async (photoId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'photoId' is not null or undefined
            if (photoId === null || photoId === undefined) {
                throw new RequiredError('photoId','Required parameter photoId was null or undefined when calling findPhoto.');
            }
            const localVarPath = `/photos/{photoId}`
                .replace(`{${"photoId"}}`, encodeURIComponent(String(photoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhotosApi - functional programming interface
 * @export
 */
export const PhotosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes the photo for the given id
         * @param {string} photoId The id of the photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePhoto(photoId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await PhotosApiAxiosParamCreator(configuration).deletePhoto(photoId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the photos for a given event, optionally filtered by albums and bib number
         * @param {string} eventId The event id
         * @param {string} [albumsIdsString] 
         * @param {string} [lastPagePhotoId] 
         * @param {string} [bibNumber] The bib number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findEventPhotos(eventId: string, albumsIdsString?: string, lastPagePhotoId?: string, bibNumber?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PickPhotoExcludeKeyofPhotoSourceImageUrl>>> {
            const localVarAxiosArgs = await PhotosApiAxiosParamCreator(configuration).findEventPhotos(eventId, albumsIdsString, lastPagePhotoId, bibNumber, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves the photo for the given id
         * @param {string} photoId The id of the photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPhoto(photoId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Photo>> {
            const localVarAxiosArgs = await PhotosApiAxiosParamCreator(configuration).findPhoto(photoId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PhotosApi - factory interface
 * @export
 */
export const PhotosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes the photo for the given id
         * @param {string} photoId The id of the photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhoto(photoId: string, options?: any): AxiosPromise<boolean> {
            return PhotosApiFp(configuration).deletePhoto(photoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the photos for a given event, optionally filtered by albums and bib number
         * @param {string} eventId The event id
         * @param {string} [albumsIdsString] 
         * @param {string} [lastPagePhotoId] 
         * @param {string} [bibNumber] The bib number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findEventPhotos(eventId: string, albumsIdsString?: string, lastPagePhotoId?: string, bibNumber?: string, options?: any): AxiosPromise<Array<PickPhotoExcludeKeyofPhotoSourceImageUrl>> {
            return PhotosApiFp(configuration).findEventPhotos(eventId, albumsIdsString, lastPagePhotoId, bibNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the photo for the given id
         * @param {string} photoId The id of the photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPhoto(photoId: string, options?: any): AxiosPromise<Photo> {
            return PhotosApiFp(configuration).findPhoto(photoId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deletePhoto operation in PhotosApi.
 * @export
 * @interface PhotosApiDeletePhotoRequest
 */
export interface PhotosApiDeletePhotoRequest {
    /**
     * The id of the photo
     * @type {string}
     * @memberof PhotosApiDeletePhoto
     */
    readonly photoId: string
}

/**
 * Request parameters for findEventPhotos operation in PhotosApi.
 * @export
 * @interface PhotosApiFindEventPhotosRequest
 */
export interface PhotosApiFindEventPhotosRequest {
    /**
     * The event id
     * @type {string}
     * @memberof PhotosApiFindEventPhotos
     */
    readonly eventId: string

    /**
     * 
     * @type {string}
     * @memberof PhotosApiFindEventPhotos
     */
    readonly albumsIdsString?: string

    /**
     * 
     * @type {string}
     * @memberof PhotosApiFindEventPhotos
     */
    readonly lastPagePhotoId?: string

    /**
     * The bib number
     * @type {string}
     * @memberof PhotosApiFindEventPhotos
     */
    readonly bibNumber?: string
}

/**
 * Request parameters for findPhoto operation in PhotosApi.
 * @export
 * @interface PhotosApiFindPhotoRequest
 */
export interface PhotosApiFindPhotoRequest {
    /**
     * The id of the photo
     * @type {string}
     * @memberof PhotosApiFindPhoto
     */
    readonly photoId: string
}

/**
 * PhotosApi - object-oriented interface
 * @export
 * @class PhotosApi
 * @extends {BaseAPI}
 */
export class PhotosApi extends BaseAPI {
    /**
     * Deletes the photo for the given id
     * @param {PhotosApiDeletePhotoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotosApi
     */
    public deletePhoto(requestParameters: PhotosApiDeletePhotoRequest, options?: any) {
        return PhotosApiFp(this.configuration).deletePhoto(requestParameters.photoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the photos for a given event, optionally filtered by albums and bib number
     * @param {PhotosApiFindEventPhotosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotosApi
     */
    public findEventPhotos(requestParameters: PhotosApiFindEventPhotosRequest, options?: any) {
        return PhotosApiFp(this.configuration).findEventPhotos(requestParameters.eventId, requestParameters.albumsIdsString, requestParameters.lastPagePhotoId, requestParameters.bibNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the photo for the given id
     * @param {PhotosApiFindPhotoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhotosApi
     */
    public findPhoto(requestParameters: PhotosApiFindPhotoRequest, options?: any) {
        return PhotosApiFp(this.configuration).findPhoto(requestParameters.photoId, options).then((request) => request(this.axios, this.basePath));
    }
}


